[I. Map Coloring](https://codeforces.com/gym/100488/problem/I?__cf_chl_tk=4.CQybNR5PpxasNBj5ez5FDguhoOV_q0ac2V7aS92HY-1759157221-1.0.1.1-8EwleBb6KEluvHPwkSiSHDyUqV6O423_iID23KjMbQ4)

**题意：** 给出一个有n个点，m条边的图，要求最多用k种颜色给每个点染色，但是必须保证两个点颜色不同当前仅当两点之间有一条边，问能否成功涂色，成功输出方案，否则输出-1

开始我自己写的时候想到了说吧点之间没有边的搞成一个连通块，但是由于写的太烂而且也不对直接就错了，正确方式是构造反图。用临界矩阵就可以轻松维护，把p[i][j] = 0的当成有边不就行啦，我开始想的是边涂色边判断涂的这个是否满足，但是这样会非常麻烦，我写的是看被涂的点是否已经涂过，原理是一个点不能有两种颜色，但是是不对的，看看样例3就明白了

所以我们不如就先按照最好的方式填，最后再判断是否合法就行

```cpp[]
void solve(){
    int n, m, k;
    cin >> n >> m >> k;
    int u, v;
    vector<vector<int>> p(n + 1, vector<int>(n + 1));
    fore(i, 1, m + 1) {
        cin >> u >> v;
        p[u][v] = p[v][u] = 1;
    }
    vector<int> col(n + 1);
    int cur = 0;
    auto dfs = [&](auto &&dfs, int s) -> void
    {
        col[s] = cur;
        fore(i, 1, n + 1) if (!p[s][i] && !col[i]) dfs(dfs, i);
    };
    fore(i, 1, n + 1) {
        if(col[i]) continue;
        cur++;
        dfs(dfs, i);
    }
    int flag = true;
    if(cur > k) flag = false;
    fore(i, 1, n + 1) fore(j, 1, n + 1) if (p[i][j] && col[i] == col[j]) flag = false;
    if(flag) {
        fore(i, 1, n + 1) cout << col[i] << " \n"[i == n];
    }else {
        cout << -1 << endl;
    }
}
```

