#### [D - On AtCoder Conference](https://atcoder.jp/contests/abc429/tasks/abc429_d)

**题意** 现在一个长度为m的环，一共有n个人分别站在不同的位置，现在以每个点为初始点出发顺时针走，直到遇到的人数大于等于c，问最后总和是多少

可以先对人的位置排序，我们从第i个人开始走的话，最后一定要找到第i + c - 1个人，最后如果有很多人都在这个点就需要再加上一些，这个可以用nxt数组简单维护

```cpp
void solve() {
    int n, m, c;
    cin >> n >> m>> c;
    vector<int> pos(n + 1);
    fore(i, 1, n + 1) cin >> pos[i];
    sort(pos.begin() + 1, pos.end());
    vector<int> nxt(n + 1);
    nxt[n] = n;
    for(int i = n - 1; i >= 1; i--) {
        if(pos[i] != pos[i + 1]) nxt[i] = i;
        else nxt[i] = nxt[i + 1];
    }
    int ans = 0;
    fore(i, 1, n + 1) {
        int j = (i - 1 + c - 1) % n + 1;
        ans += (i == 1 ? pos[1] + m - pos[n] : pos[i] - pos[i - 1]) * (c + nxt[j] - j);
    }
    cout << ans << endl;
}
```


#### [E - Hit and Away](https://atcoder.jp/contests/abc429/tasks/abc429_e)

**题意：** 给出一个图，每个点是否安全由一个字符串给出，对于每个危险顶点v输出从某个安全点开始经过v到另一个安全顶点的最短步数

这题相当于是一个多源最短路的升级版，但是原理是一样的，先找出多原点，再用bfs更新其他的位置

由于要维护最小值和次小值，我们往外更新时我们必须直到什么？现在该更新的是这个点的最小值还是次小值，如果是次次小值是否和最小值的点重合

所以另外开两个数组from[n][2]和d[n][2]维护从哪里来以及距离是多少

最后就是简单的到了新的点就看能不能更新，能更新就更新再加入这个点，用这个点去更新别的点

```cpp
void solve(){
    int n, m;
    cin >> n >> m;
    vector<vector<int>> p(n + 1);
    int u, v;
    fore(i, 1, m + 1) {
        cin >> u >> v;
        p[u].emplace_back(v);
        p[v].emplace_back(u);
    }
    string s;
    cin >> s;
    s = " " + s;
    vector<vector<int>> from(n + 2, vector<int>(2)), d = from;
    fore(i, 1, n + 1) d[i][0] = d[i][1] = -1;
    queue<pii> q;
    fore(i, 1, n + 1) {
        if(s[i] == 'S') {
            q.emplace(i, 0);
            from[i][0] = i, d[i][0] = 0;
        }
    }
    while(!q.empty()) {
        auto[s, st] = q.front(); q.pop();
        for(int to : p[s]) {
            if(d[to][0] == -1) {
                d[to][0] = d[s][st] + 1;
                from[to][0] = from[s][st];
                q.emplace(to, 0);
            }else if(d[to][1] == -1 && from[to][0] != from[s][st]) {
                d[to][1] = d[s][st] + 1;
                from[to][1] = from[s][st];
                q.emplace(to, 1);
            }
        }
    }
    fore(i, 1, n + 1) {
        if(s[i] == 'D') cout << d[i][0] + d[i][1] << endl;
    }
}
```


#### [F - Shortest Path Query](https://atcoder.jp/contests/abc429/tasks/abc429_f)

**题意：** 给出一个3行n列的地图，中间可能是墙壁或者空地，对于每次询问翻转某个点的状态，问从(1, 1)到(3, n)的最短路径长度是多少

如果没有修改操作，我们怎么算？直接dp一遍就行，因为其实不能回头走所以对于dp[1][k] = min(dp[1][k - 1] + 1, dp[2][k - 1] + 2, dp[3][k - 1] + 3)

这里细节是从前一列到后一列最优一定是第一步往右走，如果上下移动那就可以从哪个点直接往右走一步得到

这里可以得出一个矩阵称作转移矩阵， $dp_{i - 1} = dp_i * Matrix$ 这里的 * 并不是一半的乘法，而是(min, +)操作，这个可以记住是具有结合律的

对于每一列我们都可以算出这个矩阵 $A_i$ 最后结果就是 $A_1 * A_2 * ... * A_n$ 这个矩阵的第一行第三列的数，矩阵的意义就是从i行到下一列的j行需要的步数

每次修改操作就只修改了一个矩阵 $A_i$ 剩下的都没变，所以用线段树维护区间乘积

```cpp
struct Matrix {
    int a[3][3];
    Matrix() {
        fore(i, 0, 3) fore(j, 0, 3) a[i][j] = inf;
    }
    Matrix operator* (const Matrix& x) {
        Matrix ans;
        fore(i, 0, 3) fore(j, 0, 3) fore(k, 0, 3) {
            ans.a[i][j] = min(ans.a[i][j], a[i][k] + x.a[k][j]);
        }
        return ans;
    }
};

class Seg {
public:
    int n;
    vector<Matrix> a, info;
    Seg(int n) : n(n), a(n + 1), info((n << 2) + 1) {}
    
    void build(int i, int l, int r) {
        if (l == r) {
            info[i] = a[l];
        } else {
            int mid = (l + r) >> 1;
            build(i << 1, l, mid);
            build(i << 1 | 1, mid + 1, r);
            info[i] = info[i << 1] * info[i << 1 | 1];
        }
    }
    
    void set(int pos, Matrix val, int l, int r, int i) {
        if (l == r) {
            a[pos] = val;
            info[i] = val;
            return;
        }
        int mid = (l + r) >> 1;
        if (pos <= mid) {
            set(pos, val, l, mid, i << 1);
        } else {
            set(pos, val, mid + 1, r, i << 1 | 1);
        }
        info[i] = info[i << 1] * info[i << 1 | 1];
    }
};

void solve() {
    int n;
    cin >> n;
    vector<string> s(3);
    fore(i, 0, 3) {
        cin >> s[i];
        s[i] = " " + s[i];
    }
    
    auto buildMatrix = [&](int col) -> Matrix {
        Matrix res;
        bool c0 = (s[0][col] == '.');
        bool c1 = (s[1][col] == '.');
        bool c2 = (s[2][col] == '.');
        
        res.a[0][0] = c0 ? 1 : inf;
        res.a[1][0] = (c0 && c1) ? 2 : inf;
        res.a[2][0] = (c0 && c1 && c2) ? 3 : inf;
        
        res.a[1][1] = c1 ? 1 : inf;
        res.a[0][1] = (c0 && c1) ? 2 : inf;
        res.a[2][1] = (c1 && c2) ? 2 : inf;
        
        res.a[2][2] = c2 ? 1 : inf;
        res.a[1][2] = (c1 && c2) ? 2 : inf;
        res.a[0][2] = (c0 && c1 && c2) ? 3 : inf;
        
        return res;
    };

    Seg t(n);
    fore(i, 1, n + 1) {
        t.a[i] = buildMatrix(i);
    }
    t.build(1, 1, n);
    
    int q; cin >> q;
    while (q--) {
        int r, c;
        cin >> r >> c;
        r--;
    
        if (s[r][c] == '#') s[r][c] = '.';
        else s[r][c] = '#';
        Matrix tmp = buildMatrix(c);
        t.set(c, tmp, 1, n, 1);
        
        int ans = t.info[1].a[0][2];
        if (ans >= inf) {
            cout << -1 << endl;
        } else {
            cout << ans - 1 << endl;
        }
    }
}
```
