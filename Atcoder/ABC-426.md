#### [D - Pop and Insert](https://atcoder.jp/contests/abc426/tasks/abc426_d)

**题意：** 给出一个01字符串，你每次可以翻转一个字符后将其插入到任意一个位置，问最少操作多少次可以让所有字符都相同

假设最终都是0的话，我们选定一块连续的0不动，之后的都插入到这一段中，发现如果是1就只要一次否则就要两次，选出最长的0字串就行，另外一种是最终为1，分类讨论即可

```cpp
void solve() {
    int n;
    cin >> n;
    string s;
    cin >> s;
    s = " " + s;
    int l0 = 0, r0 = -1, l1 = 0, r1 = -1; // 这里开始不能是0，0，一定要保证 r - l + 1 至多是0
    for(int l = 1, r = 1; l <= n; r++, l = r) {  //这里l <= n还是r <= n都行，最后循环结束后的增量别写错就行
        while(r < n && s[r + 1] == s[l]) r++;
        if(s[l] == '0' && r - l + 1 > r0 - l0 + 1) {
            l0 = l, r0 = r;
        }else if(s[l] == '1' && r - l + 1 > r1 - l1 + 1) {
            l1 = l, r1 = r;
        }
    }
    // cout << l0 << ' ' << r0 << endl;
    int ans = inf;
    int tmp = 0;
    fore(i, 1, n + 1) {
        if(i >= l0 && i <= r0) continue;
        tmp += (s[i] == '0' ? 2 : 1);
    }
    ans = min(ans, tmp);
    tmp = 0;
    fore(i, 1, n + 1) {
        if(i >= l1 && i <= r1) continue;
        tmp += (s[i] == '1' ? 2 : 1);
    }
    ans = min(ans, tmp);
    cout << ans << endl;
}
```

#### [E - Closest Moment](https://atcoder.jp/contests/abc426/tasks/abc426_e)

**题意：** 在二维平面上高桥和青木都在行走且都有自己的起点和终点，他们速度都是1，问两人最近距离是多少

题目难点在与向量关系的转化，可以用一个向量来表示每个人此时的位置，可以知道的是最后的函数肯定是一个凹函数，所以要用到三分法

具体来说就是找到三分点 lm = (l + l + r) / 3 (左) 和 rm = (l + r + r) / 3) (右) 如果f(rm) > f(lm) : r = rm 否则 l = lm

如何维护时刻t每个人的位置？可以先计算出位移向量，除以行走时间就得到了速度向量， $\vec{P} = \vec{S} + \vec{V} * t$ 这样就维护出了每个人的位置

最后两人距离的方程就可以写出来了，但是有一点需要注意的就是一个人会先停下，所以可以设置第一个人是先停下的那一个，最后算第二段的时候第一个人二点速度向量是0就行

```cpp
struct Vec { double x, y;};

Vec operator + (Vec a, Vec b) {return (Vec){a.x + b.x, a.y + b.y};}
Vec operator - (Vec a, Vec b) {return (Vec){a.x - b.x, a.y - b.y};}
Vec operator * (double a, Vec b) {return (Vec){a * b.x, a * b.y};}
Vec operator * (Vec a, double b) {return (Vec){a.x * b, a.y * b};}
Vec operator / (Vec a, double b) {return (Vec){a.x / b, a.y / b};}
void operator /= (Vec& a, double b) {a.x /= b, a.y /= b;}

double len(Vec v) { return sqrt(v.x * v.x + v.y * v.y);}
double len(db x, db y) {return sqrt(x * x + y * y);}
double dis(Vec a, Vec b) {return len(a - b);}

double fun(Vec TS, Vec TV, Vec AS, Vec AV, double T) {
    double l = 0, r = T;
    fore(i, 0, 60) {
        double ml = (l + l + r) / 3;
        double mr = (l + r + r) / 3;
        Vec TL = TS + TV * ml, TR = TS + TV * mr;
        Vec AL = AS + AV * ml, AR = AS + AV * mr;
        if(dis(TL, AL) < dis(TR, AR)) r = mr;
        else l = ml;
    }
    return dis(TS + l * TV, AS + l * AV);
}


void solve() {
    db Tsx, Tsy, Tex, Tey;
    db Asx, Asy, Aex, Aey;
    cin >> Tsx >> Tsy >> Tex >> Tey;
    cin >> Asx >> Asy >> Aex >> Aey;
    db Tvx = Tex - Tsx, Tvy = Tey - Tsy;
    db Avx = Aex - Asx, Avy = Aey - Asy;
    
    Vec Tv = {Tvx, Tvy}, Av = {Avx, Avy};
    double tt = len(Tv), ta = len(Av);
    if(tt > ta) {
        swap(tt, ta);
        swap(Tv, Av);
        swap(Tsx, Asx);
        swap(Tsy, Asy);
        swap(Tex, Aex);
        swap(Tey, Aey);
    }

    Vec TS = {Tsx, Tsy}, TE = {Tex, Tey};
    Vec AS = {Asx, Asy}, AE = {Aex, Aey};
    Tv /= tt, Av /= ta;
    double ans = min(fun(TS, Tv, AS, Av, tt), fun(TE, (Vec){0, 0}, AS + Av * tt, Av, ta - tt));
    cout << setprecision(15) << ans << endl;
}

```

#### [F - Clearance](https://atcoder.jp/contests/abc426/tasks/abc426_f)

**题意：** 商店中有n中货物，每种的数量是 $C_i$ 个，你需要处理q次询问，每次询问给出一个l, r, k，代表购买编号从l到r的商品k个，如果不够就买走剩下所有的，输出每次买走的商品总数

明显的线段树题，需要维护什么信息呢？

发现我们只需要维护区间的最小值(minn)以及当前区间非零元素的个数(cnt)就行

分两种情况讨论，1.如果minn[i] > k并且包含整个区间，那么说明存货是够的，结果就是k * cnt[i]，然后打上懒标记(理解：打标记就是先把当前的位置更新了再记录标记，是真的把当前位置更新了！因此后面每次push或者query到i的时候如果不是全覆盖都要down一次) 2. 说明有的元素不够了，就直接暴力往下递归，一直递归到叶子节点处理

```cpp
class SegTree{
public:
    int n;
    vector<int> cnt, add, val, minn;
    SegTree(int n) : n(n), cnt((n << 2) + 1, 0), add((n << 2) + 1, 0), minn((n << 2) + 1), val(n + 1) {}

    void build(int i, int l, int r) {
        if(l == r) {
            cnt[i] = 1;
            minn[i] = val[l];
            return;
        }else{
            int mid = (l + r) >> 1;
            build(i << 1, l, mid);
            build(i << 1 | 1, mid + 1, r);
            up(i);
        }
    }
    void up(int i) {
        cnt[i] = cnt[i << 1] + cnt[i << 1 | 1];
        minn[i] = min(minn[i << 1], minn[i << 1 | 1]);
    }
    void down(int i) {
        if(add[i] == 0) return;
        upgrade(i << 1, add[i]);
        upgrade(i << 1 | 1, add[i]);
        add[i] = 0;
    }
    void upgrade(int i, int val) {
        minn[i] += val;
        add[i] += val;
    }
    int push(int jobl, int jobr, int jobv, int l, int r, int i) {
        if(cnt[i] == 0) return 0;
        if(jobl <= l && jobr >= r && minn[i] > jobv) {
            upgrade(i, -jobv);
            return cnt[i] * jobv;
        }
        if(l == r) {
            cnt[i] = 0;
            int tmp = minn[i];
            minn[i] = inf;
            return tmp;
        }
        int mid = (l + r) >> 1;
        down(i);
        int ans = 0;
        if(jobl <= mid) ans += push(jobl, jobr, jobv, l, mid, i << 1);
        if(jobr > mid) ans += push(jobl, jobr, jobv, mid + 1, r, i << 1 | 1);
        up(i);
        return ans;
    }
};

void solve() {
    int n; cin >> n;
    SegTree sg(n);
    fore(i, 1, n + 1) cin >> sg.val[i];
    sg.build(1, 1, n);

    int q; cin >> q;
    while(q--) {
        int l, r, k;
        cin >> l >> r >> k;
        cout << sg.push(l, r, k, 1, n, 1) << endl;
    }
}

```

