#### [D - 183184](https://atcoder.jp/contests/abc428/tasks/abc428_d)

**题意：** 给出一个C和D，定义 $f(12, 3) = 123$ ，求出对于所有的 $f(C, C + x), x \in [1, D]$ 中有多少个平方数

首先必须知道的是对于 $[1, n]$ 中平方数的个数是 $\lfloor \sqrt{n} \rfloor$

最后数的大小取决于 C+x 的位数，位数并不多，可以直接枚举，这样就可以得到一个范围 $10^{d - 1} <= C+x <= 10^{d} - 1$ 进而得到位数为i时x的范围(注意边界 $1 <= x <= D$ )

知道了x的范围也就可以得到此时 C+x 的范围，可以用上面结论直接计算了

```cpp
vector<int> p(11);
void init(){
    p[0] = 1;
    fore(i, 1, 11) p[i] = p[i - 1] * 10;
}

void solve() {
    int c, d;
    cin >> c >> d;
    int ans = 0;
    fore(i, 1, 11) {
        int l = max(1ll, p[i - 1] - c), r = min(d, p[i] - 1 - c);
        if(l > r) continue;
        ans += (int)sqrtl(c * p[i] + c + r) - (int)sqrtl(c * p[i] + c + l - 1);
    }
    cout << ans << endl;
}
```



#### [E - Farthest Vertex ](https://atcoder.jp/contests/abc428/tasks/abc428_e)

**题意：** 给出一棵树，计算距离每个点的最远点，如果距离相等选编号更大的那个

明显的换根dp，但是我调了好久都没调出来

关键点：
- 初始的pre_dfs计算的都是方向向下的结果，虽然可能最优结果不是往下走
- g数组维护的信息是什么？第一次dfs计算后g[1]是一定要初始化的，可能不需要显式写出来，但是一定需要
- g[i]更新时间：收集完所有子节点数据后，dfs往下推之前，因为必须在往下走之前完成g的更新
- ans[i]永远只和g[i]之间有关系，ans[i]的结果和其他的都没关系，这是根据g[i]的定义来的
- v1, v2存的是以当前节点父节点为根的结果，来源是父节点s和to的兄弟节点

```cpp
void solve() {
    int n;
    cin >> n;
    vector<vector<int>> p(n + 1);
    int u, v;
    fore(i, 0, n - 1) {
        cin >> u >> v;
        p[u].emplace_back(v);
        p[v].emplace_back(u);
    }
    vector<pii> dp(n + 1), g = dp; // (dis, id)
    auto pre_dfs = [&](auto& self, int s, int fa) -> void {
        dp[s] = {0, s};
        for(int to : p[s]) {
            if(to == fa) continue;
            self(self, to, s);
            pii tmp = {dp[to].first + 1, dp[to].second};
            dp[s] = max(dp[s], tmp);
        }
    };
    pre_dfs(pre_dfs, 1, -1);
    vector<pii> ans(n + 1);
    fore(i, 1, n + 1) ans[i] = dp[i];
    g[1] = {0, 1};
    auto dfs = [&](auto&& dfs, int s, int fa) -> void {
        pii v1 = g[s], v2 = {0, -1};
        for(int to : p[s]) {
            if(to == fa) continue;
            pii tmp = {dp[to].first + 1, dp[to].second};
            if(tmp > v1) v2 = v1, v1 = tmp;
            else if(tmp > v2) v2 = tmp;
        }
    
        for(int to : p[s]) {
            if(to == fa) continue;
            pii cur = {dp[to].first + 1, dp[to].second};
            if(cur != v1) g[to] = {v1.first + 1, v1.second};
            else g[to] = {v2.first + 1, v2.second};
            ans[to] = max(ans[to], g[to]);
            dfs(dfs, to, s);
        }
    };
    dfs(dfs, 1, -1);
    fore(i, 1, n + 1) cout << ans[i].second << endl;
}
```

#### [F - Pyramid Alignment](https://atcoder.jp/contests/abc428/tasks/abc428_f)

**题意：** 给出n个线段，初始线段i的范围是[0, w[i]]，一共有q次操作
- op = 1，给出编号v，将所有小于等于编号v的线段移动至和x线段左端点重合
- op = 2，~~~右端点重合
- op = 3，给出坐标x，输出有多少个线段覆盖了 x + 0.5 这个点


可以发现的性质是线段i只可以在线段i+1的区间中移动，不可能超过

可以想想每次"对齐"后这些线段其实可以看成一个整体了，对于这个整体中的线段，只需要知道编号就能知道它覆盖的范围

我们对每个块维护四个信息(l, r, x, t)，分别是这个块包含的线段的范围，x:对齐的是哪个点，t = 0:左对齐，1是右对齐

每次进行移动操作时先用二分找到这个编号在哪个块中，这个就是很简单的一个二分，利用的是维护的(l, r)这一对信息，找到这个块后就可以得到这个线段具体的范围，具体就是query函数干的事

先一步就该修改数据了，对于所有r小于等于v的这些块都可以直接删了，和之后的一起合并，如果v在[l, r)之间就要拆分这个区间，具体的就是一直pop_back()，到最后一个区间时修改sg.back().l = v + 1就行，最后再加入这个新的合并的区间

对于查询需要两次二分，这里方向还不一样，第一次我们二分找到这个x在的块，第二次二分找的是这个块中第一个包含这个点的线段编号

第一次二分的sg是降序排列的，第二次二分的sg[cur]是升序的，需要注意

最后结果就是 n - l - 1，如果第一步找不到这个块就直接是0，因为我的二分没有使用额外的变量保存最后结果，是直接使用的l，所以需要再检查一下是不是真的找到了

复杂度是没问题的，每次修改只会最多加入两个新区间，所以最多也只能删这么多，实际是O(n)的算法，非常快

```cpp

struct seg{
    int l, r, x, t;
};
vector<seg> sg;
vector<int> w;

pair<int, int> query(seg sg, int x) { // 找到x的左右端点
    if(sg.t == 0) return {sg.x, sg.x + w[x]};
    else return {sg.x - w[x], sg.x}; 
}

pair<int, int> findx(int x) { // 找到编号x所在区间
    int l = 0, r = sg.size() - 1, mid;
    while(l < r) {
        int mid = (l + r + 1) >> 1;
        if(sg[mid].r >= x) l = mid;
        else r = mid - 1;
    }
    return query(sg[l], x);
}

void solve() {
    int n;
    cin >> n;
    w.resize(n + 1);
    fore(i, 1, n + 1) cin >> w[i];
    for(int i = n; i >= 1; i--) sg.push_back(seg(i, i, w[i], 1));
    int q, v, x;
    cin >> q;
    while(q--) {
        int op;
        cin >> op;
        if(op <= 2) {
            cin >> v;
            pii tmp = findx(v);
            while(!sg.empty()) {
                if(sg.back().r <= v) sg.pop_back();
                else {
                    sg.back().l = v + 1;
                    break;
                }
            }
            if(op == 1) sg.emplace_back(1, v, tmp.first, 0);
            else sg.emplace_back(1, v, tmp.second, 1);
        }else {
            cin >> v;
            int l = 0, r = sg.size() - 1, mid;
            while(l < r) {
                int mid = (l + r + 1) >> 1;
                pii tmp = query(sg[mid], sg[mid].r);
                if(tmp.first <= v && tmp.second > v) l = mid;
                else r = mid - 1;
            }
            int cur = l;
            pii tmp = query(sg[cur], sg[cur].r);
            if(tmp.first > v || tmp.second <= v) {
                cout << 0 << endl;
                continue;
            }
            l = sg[cur].l, r = sg[cur].r;
            while(l < r) {
                int mid = (l + r) >> 1;
                pii tmp = query(sg[cur], mid);
                if(tmp.first <= v && tmp.second > v) r = mid;
                else l = mid + 1;
            }
            cout << n - l + 1 << endl;
        }
    }
}

```
