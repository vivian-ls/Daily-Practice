#### [E - Farthest Vertex ](https://atcoder.jp/contests/abc428/tasks/abc428_e)

**题意：** 给出一棵树，计算距离每个点的最远点，如果距离相等选编号更大的那个

明显的换根dp，但是我调了好久都没调出来

关键点：
- 初始的pre_dfs计算的都是方向向下的结果，虽然可能最优结果不是往下走
- g数组维护的信息是什么？第一次dfs计算后g[1]是一定要初始化的，可能不需要显式写出来，但是一定需要
- g[i]更新时间：收集完所有子节点数据后，dfs往下推之前，因为必须在往下走之前完成g的更新
- ans[i]永远只和g[i]之间有关系，ans[i]的结果和其他的都没关系，这是根据g[i]的定义来的
- v1, v2存的是以当前节点父节点为根的结果，来源是父节点s和to的兄弟节点

```cpp
void solve() {
    int n;
    cin >> n;
    vector<vector<int>> p(n + 1);
    int u, v;
    fore(i, 0, n - 1) {
        cin >> u >> v;
        p[u].emplace_back(v);
        p[v].emplace_back(u);
    }
    vector<pii> dp(n + 1), g = dp; // (dis, id)
    auto pre_dfs = [&](auto& self, int s, int fa) -> void {
        dp[s] = {0, s};
        for(int to : p[s]) {
            if(to == fa) continue;
            self(self, to, s);
            pii tmp = {dp[to].first + 1, dp[to].second};
            dp[s] = max(dp[s], tmp);
        }
    };
    pre_dfs(pre_dfs, 1, -1);
    vector<pii> ans(n + 1);
    fore(i, 1, n + 1) ans[i] = dp[i];
    g[1] = {0, 1};
    auto dfs = [&](auto&& dfs, int s, int fa) -> void {
        pii v1 = g[s], v2 = {0, -1};
        for(int to : p[s]) {
            if(to == fa) continue;
            pii tmp = {dp[to].first + 1, dp[to].second};
            if(tmp > v1) v2 = v1, v1 = tmp;
            else if(tmp > v2) v2 = tmp;
        }
    
        for(int to : p[s]) {
            if(to == fa) continue;
            pii cur = {dp[to].first + 1, dp[to].second};
            if(cur != v1) g[to] = {v1.first + 1, v1.second};
            else g[to] = {v2.first + 1, v2.second};
            ans[to] = max(ans[to], g[to]);
            dfs(dfs, to, s);
        }
    };
    dfs(dfs, 1, -1);
    fore(i, 1, n + 1) cout << ans[i].second << endl;
}
```
