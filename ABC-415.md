1. [D - Get Many Stickers](https://atcoder.jp/contests/abc415/tasks/abc415_d)
   
   题意：开始又n瓶可乐，店员有m种方案，分别时用a个空瓶换b瓶可乐和一张贴纸，问最多可以得到多少张贴纸
   
   发现一张贴纸的价值就是b - a，所以按这个值排序计算即可
   
   ```c++
   void solve() {
       int n, m;
       cin >> n >> m;
       int a, b;
       vector<pii> val(m + 1);
       fore(i, 1, m + 1) {
           cin >> a >> b;
           val[i] = {a - b, a};
       }
       sort(val.begin() + 1, val.end());
       int ans = 0;
       fore(i, 1, m + 1) {
           if(n < val[i].second) continue;
           int sum = (n - val[i].second) / val[i].first + 1;
           ans += sum;
           n -= val[i].first * sum;
       }
       cout << ans << endl;
   }
   
   ```

2. [E - Hungry Takahashi](https://atcoder.jp/contests/abc415/tasks/abc415_e)
   
   题意：给出一个n * m 的网格，每个格子里面都有一定的金币，每一可以向下或者向右走一格，开始位于(1, 1)，每天依次发生下面的时间，收集当前位置的金币，花费$P_i$个金币购买食物，如果金币不够就会饿死，问开始至少有多少金币才能完成n + m - 1天
   
   对于每一个格子的价值可以提前维护出来，距离出生点多远就减去对应值即可，问题在于如何知道开始需要多少，二分即可，对于每一个二分的值跑一个dp，看终点的dp值是否>=0 即可
   
   ```c++
   void solve() {
       int n, m;
       cin >> n >> m;
       vector<vector<int>> p(n + 1, vector<int>(m + 1));
       fore(i, 1, n + 1) fore(j, 1, m + 1) cin >> p[i][j];
       vector<int> cost(n + m);
       fore(i, 1, n + m) cin >> cost[i];
   
       fore(i, 1, n + 1) fore(j, 1, m + 1) p[i][j] -= cost[i + j - 1];  //小技巧
       int l = 0, r = lnf, mid;
   
       auto check = [&](int mid) -> bool {
           vector<vector<int>> dp(n + 1, vector<int>(m + 1, -inf));
           dp[1][1] = p[1][1] + mid;
           fore(i, 1, n + 1) fore(j, 1, m + 1) {
               if(i - 1 >= 1 && dp[i - 1][j] >= 0)
                   dp[i][j] = max(dp[i][j], dp[i - 1][j] + p[i][j]);
               if(j - 1 >= 1 && dp[i][j - 1] >= 0)
                   dp[i][j] = max(dp[i][j], dp[i][j - 1] + p[i][j]);
           }
           return dp[n][m] >= 0;
       };
       while(l < r) {
           mid = (l + r) >> 1;
           if(check(mid)) r = mid;
           else l = mid + 1;
       }
       cout << l << endl;
   }
   ```

3. [F - Max Combo](https://atcoder.jp/contests/abc415/tasks/abc415_f)
   
   题意：给出一个长度为n的字符串s，实现两个操作：将第x个字符修改为p，输出最长连续字符的长度
   
   经典的线段树题，注意info加号的重载即可
   
   ```c++
   struct Info {
       int len, len_l, len_r, ans;
       char ch_l, ch_r;
   };
   
   Info operator+(const Info& l, const Info& r){
       Info u;
       u.len = l.len + r.len;
       u.ch_l = l.ch_l;
       u.ch_r = r.ch_r;
   
       u.len_l = l.len_l;
       if(l.len_l == l.len && l.ch_l == r.ch_l)
           u.len_l += r.len_l;
       u.len_r = r.len_r;
       if(r.len_r == r.len && r.ch_r == l.ch_r)
           u.len_r += l.len_r;
       u.ans = max(l.ans, r.ans);
       if(l.ch_r == r.ch_l)
           u.ans = max(u.ans, l.len_r + r.len_l);
       return u;
   }
   
   struct SegmentTree{
       int n;
       vector<Info> info;
    
       SegmentTree(int n, vector<Info>& a) : n(n), info((n << 2) + 1, Info()) {
           function<void(int, int, int)> build = [&](int i, int l, int r) {
               if(l == r) {
                   info[i] = a[l];
                   return;
               }
               int mid = (l + r) >> 1;
               build(i << 1, l, mid);
               build(i << 1 | 1, mid + 1, r);
               up(i);
           };
           build(1, 1, n);  //
       }
       void up(int i) { info[i] = info[i << 1] + info[i << 1 | 1]; } //
   
       void Modify(int i, int l, int r, int pos, Info& v) {
           if(l == r) {
               info[i] = v;
               return;
           }
           int mid = (l + r) >> 1;
           if(pos <= mid)
               Modify(i << 1, l, mid, pos, v);
           else
               Modify(i << 1 | 1, mid + 1, r, pos, v);
           up(i);
       }
       void modify(int pos, Info& v) {
           Modify(1, 1, n, pos, v);
       }
    
       Info Query(int jobl, int jobr, int l, int r, int i) {
           if(jobl <= l && jobr >= r)
               return info[i];
           int mid = (l + r) >> 1;
           if(jobr <= mid)
               return Query(jobl, jobr, l, mid, i << 1);
           if(jobl > mid)
               return Query(jobl, jobr, mid + 1, r, i << 1 | 1);
           return Query(jobl, jobr, l, mid, i << 1) + Query(jobl, jobr, mid + 1, r, i << 1 | 1);
       }
       Info query(int l, int r){
           return Query(l, r, 1, n, 1);
       }
   };
   
   void solve() {
       int n, q;
       string s;
       cin >> n >> q >> s;
       s = " " + s;
       vector<Info> a(n + 1);
       fore(i, 1, n + 1) a[i] = {1, 1, 1, 1, s[i], s[i]};
       SegmentTree t(n, a);
       int p, l, r, op;
       char x;
       fore(i, 0, q) {
           cin >> op;
           if(op == 1) {
               cin >> p >> x;
               Info v = {1, 1, 1, 1, x, x};
               t.modify(p, v);
           }else{
               cin >> l >> r;
               cout << t.query(l, r).ans << endl;
           }
       }
   }
   ```


