#### [J. Jovial Jaunt](https://codeforces.com/gym/105012/problem/J)

**题意：** 给出一个有n个点的树，每一个点有一个权值，对于函数f(x)有如下定义

-   $f(x_1) = x_1$.
-   $f(x_1, x_2) = \max{(x_1, x_2)} + \lfloor\sqrt{\min{(x_1, x_2)}}\rfloor$.
-   For $k > 2$, $f(x_1, x_2, \ldots, x_k) = f(f(x_1,\ldots, x_{k-1}), x_k)$.

你可以任意选择起点和终点，问最后可以得到的 $f(x_1, x_2, ...)$ 最大的值是多少？

🔔开始我的误区是想着怎么合并一上一下实际根本不用

开始我想的是经过val最大的那个点，然后向上下两边扩展，但是并不对，因为不是选了最大的就是最好的，这种给出路径权值要求最大化值的问题就是经典换根dp

首先预处理dfs统计dp1[i]，表示在i的子树中的任意一个点向上走到i可以得到的最大值，注意这里i是最后一个数字，这样我们才能够进行后面的转移。之后第二次dfs处理出dp2[i]表示删除以i为根的子树但是保留i后，新的根为i的类似dp1的值，类似一上一下。但是这里的dp2[i]可以来源于父亲也可以来源于当前节点的子节点，所以我们需要记录第一大的和第二大的，当我们遍历到第一大的子节点时就要用到第二大的值了。然后就做出来啦

```cpp[]
int f(int x, int y) {
    return max(x, y) + (int)sqrt(min(x, y));
}

void solve(){
    int n;
    cin >> n;
    vector<int> val(n + 1);
    fore(i, 1, n + 1) cin >> val[i];
    vector<vector<int>> p(n + 1);
    int u, v;
    fore(i, 1, n) {
        cin >> u >> v;
        p[u].emplace_back(v);
        p[v].emplace_back(u);
    }
    vector<int> dp1(n + 1), dp2 = dp1;
    auto dfs1 = [&](auto &&dfs1, int s, int fa) -> void
    {
        dp1[s] = val[s];
        for(int to : p[s]) {
            if(to == fa) continue;
            dfs1(dfs1, to, s);
            dp1[s] = max(dp1[s], f(val[s], dp1[to]));
        }
    };
    dfs1(dfs1, 1, -1);
    dp2[1] = val[1];
    auto dfs = [&](auto &&dfs, int s, int fa) -> void
    {
        int first = dp2[s], second = 0;
        for(int to : p[s]) {
            if(to == fa) continue;
            int tmp = f(dp1[to], val[s]);
            if(tmp > first) second = first, first = tmp;
            else if(tmp > second) second = tmp;
        }
        for(int to : p[s]) {
            if(to == fa) continue;
            int tmp = f(dp1[to], val[s]);
            if(tmp == first) dp2[to] = f(second, val[to]);
            else dp2[to] = f(first, val[to]);
            dfs(dfs, to, s);
        }
    };
    dfs(dfs, 1, -1);
    cout << max(*max_element(dp1.begin(), dp1.end()), *max_element(dp2.begin(), dp2.end())) << endl;
}
```
#### [C. Continued Fractions](https://codeforces.com/gym/104854/problem/C)

**题意：** 题目给出一个值p，要求找到 $10^{18}$ 范围内所有的 $a, b$ ，使其至少满足 $b | a, (b + 1) | (a + 1), (b + 2) | (a + 2), ...$ 最后结果按照从小到大输出

这种和整除有关题目肯定要用到化简的，设 $a = pb$ 是一个不错的选择

而 $pb+1=(p-1)b+(b+1), pb+2=(p-1)b+(b+2)$ 。(为什么这么做：因为我们希望分子也有一个和(b + 1)有关的式子)

所以 $(p-1)b$ 是 $b+1$ 和 $b+2$ 的倍数。

而 $(p-1)b\bmod (b+1)=-(p-1), (p-1)b\bmod(b+2)=-2(p-1)$ 。(通过整除关系进一步化简)

所以要求 $p-1$ 是 $b+1$ 的倍数，且 $2(p-1)$ 是 $b+2$ 的倍数。

因此 $2(p-1)$ 是 $b+1,b+2$ 的倍数，而 $b+1,b+2$ 是互质的，所以也就是 $(b+1)(b+2)$ 的倍数。不妨设 $2(p-1)=k(b+1)(b+2)$ 。

因为 $p$ 的范围是 $10^{18}$ ，所以 $k,b+1,b+2$ 中至少有一个元素是不超过 $(2\times 10^{18})^{1/3}$ ，所以枚举这个元素，剩余元素也都求出来了，再确认前面的条件是否满足即可（就是 $p-1$ 是 $b+1$ 的倍数，且 $2(p-1)$ 是 $b+2$ 的倍数）。

注意这里枚举的时候是最多 $10^6$ 但是结果可不是哦，对于较大的b我们要枚举k解方程得到

时间复杂度为 $\mathcal{O}(M^{1/3})$ 。

```cpp[]
void solve(){
    int p;
    cin >> p;
    vector<int> ans;
    fore(b, 1, 2000000 + 1) {
        if((p - 1) % (b + 1) == 0 && 2 * (p - 1) % (b + 2) == 0)
            ans.emplace_back(b);
    }
    fore(k, 1, 2000000 + 1) {
        if(2 * (p - 1) % k == 0) {
            int x = 2 * (p - 1) / k;
            int D = 4 * x + 1;
            int sqrtD = sqrtl(D);
            while(sqrtD * sqrtD < D) sqrtD++;
            while(sqrtD * sqrtD > D) sqrtD--;
            int b = (sqrtD - 3) / 2;
            if (b > 0 && (p - 1) % (b + 1) == 0 && 2 * (p - 1) % (b + 2) == 0)
                ans.emplace_back(b);
        }
    }
    sort(ans.begin(), ans.end());
    int k = unique(ans.begin(), ans.end()) - ans.begin();
    cout << k << endl;
    fore(i, 0, k) cout << ans[i] << " \n"[i == k - 1];
}
```

