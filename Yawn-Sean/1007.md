#### [I. Weird Divisibility](https://codeforces.com/gym/104822/problem/I)

**题意：** 给出一个数a，你需要找出一个最小的正整数b使得 $(a + b) | ab$ 

关键在于条件的转化，我们已知 $(a + b) | ab$ ，只有这个是不够的，我们需要寻找新的关系，而不是继续在这个关系中继续搞！！！我们简单调整一下可以发现一个新的式子 $(a + b) | a(a + b)$ ，两个相减就会得到新的关系 $(a + b) | a^2$ ，所以最后的结果就是找到 $a^2$ 的大于a的最小的因子就找到b了

实际算的时候我们可以容易分解出a的质因子，$a^2$ 就相当于从a的因子容器里面选择两个，根据因子的对称性，找到小于a的最大的因子，反过来就可以找到另一个

将因子排序后fac[i] * fac[n - i - 1] = n的，我们就错开一位，去计算fac[i] * fac[n - i - 2]，已知循环就找到结果了

📖通过质因数分解找出所有的因数，因数有对称性

```cpp[]
vector<int> is(40000, true);
vector<int> prime;
void init(){
    is[0] = is[1] = false;
    for (int i = 1; i <= 40000; i++) {
        if(is[i])
            prime.emplace_back(i);
        for(int p : prime) {
            if(p * i > 40000) break;
            is[p * i] = false;
            if(i % p == 0) break;
        }
    }
}

void solve(){
    int a;
    cin >> a;
    int n = a;
    map<int, int> mp;
    for(int p : prime) {
        if(n % p == 0) {
            while(n % p == 0)
                mp[p]++, n /= p;
        }
    }
    if(n > 1) mp[n]++;
    vector<int> fac = {1};
    for(auto[p, cnt] : mp) {
        int c = cnt * fac.size();
        fore(i, 0, c) fac.emplace_back(fac[i] * p);
    }
    sort(fac.begin(), fac.end());
    int ans = a * a;
    for (int i = 0; i < fac.size() - 1; i++) {
        int val = fac[i] * fac[fac.size() - i - 2];
        ans = min(ans, a * a / val - a);
    }
    cout << ans << endl;
}
```
