#### [I. Weird Divisibility](https://codeforces.com/gym/104822/problem/I)

**题意：** 给出一个数a，你需要找出一个最小的正整数b使得 $(a + b) | ab$ 

关键在于条件的转化，我们已知 $(a + b) | ab$ ，只有这个是不够的，我们需要寻找新的关系，而不是继续在这个关系中继续搞！！！我们简单调整一下可以发现一个新的式子 $(a + b) | a(a + b)$ ，两个相减就会得到新的关系 $(a + b) | a^2$ ，所以最后的结果就是找到 $a^2$ 的大于a的最小的因子就找到b了

实际算的时候我们可以容易分解出a的质因子，$a^2$ 就相当于从a的因子容器里面选择两个，根据因子的对称性，找到小于a的最大的因子，反过来就可以找到另一个

将因子排序后fac[i] * fac[n - i - 1] = n的，我们就错开一位，去计算fac[i] * fac[n - i - 2]，已知循环就找到结果了

📖通过质因数分解找出所有的因数，因数有对称性

```cpp[]
vector<int> is(40000, true);
vector<int> prime;
void init(){
    is[0] = is[1] = false;
    for (int i = 1; i <= 40000; i++) {
        if(is[i])
            prime.emplace_back(i);
        for(int p : prime) {
            if(p * i > 40000) break;
            is[p * i] = false;
            if(i % p == 0) break;
        }
    }
}

void solve(){
    int a;
    cin >> a;
    int n = a;
    map<int, int> mp;
    for(int p : prime) {
        if(n % p == 0) {
            while(n % p == 0)
                mp[p]++, n /= p;
        }
    }
    if(n > 1) mp[n]++;
    vector<int> fac = {1};
    for(auto[p, cnt] : mp) {
        int c = cnt * fac.size();
        fore(i, 0, c) fac.emplace_back(fac[i] * p);
    }
    sort(fac.begin(), fac.end());
    int ans = a * a;
    for (int i = 0; i < fac.size() - 1; i++) {
        int val = fac[i] * fac[fac.size() - i - 2];
        ans = min(ans, a * a / val - a);
    }
    cout << ans << endl;
}
```

#### [F. Unlock the Chest](https://codeforces.com/gym/106100/problem/F)

**题意：** 给出两个长度为n的数组，每次交换操作指的是对于相邻的一对(i, j)， $a[i] = a[j] - 1, a[j] = a[i] + 1$ 问a能否通过这样的操作变成b，如果可以输出最少操作次数，不能输出-1

这里这个加一减一的操作和奇怪，想想怎么把他处理掉

可以想想对数组做一个处理再还原回去，让还原的结果就是题目的交换操作

发现后面一个数就是先减去一个数x，再加上x - 1，前一个是减去y再加上y + 1，这里就可以看出是和下标有关系了，如果让每个位置的数都减去下标，就变成一个普通的互换

之后就是对于数组a，最少交换多少次得到b，这里要用到冒泡排序的原理，将a数组的元素映射成这个元素在n中的位置，之后求一个逆序数就是交换次数

注意前面的元素到对应b中更靠前的这个数

```cpp[]
class Fenwick{
public:
    int n;
    vector<int> tree;
    Fenwick(int n) : n(n), tree(n + 1) {}
    void add(int x, int val) {
        while(x <= n) {
            tree[x] += val;
            x += lowbit(x);
        }
    }
    int query(int x) {
        int ans = 0;
        while(x) {
            ans += tree[x];
            x -= lowbit(x);
        }
        return ans;
    }
};

void solve(){
    int n;
    cin >> n;
    vector<int> a(n + 1), b = a;
    fore(i, 1, n + 1) cin >> a[i], a[i] -= i;
    fore(i, 1, n + 1) cin >> b[i], b[i] -= i;

    map<int, vector<int>> mp;
    fore(i, 1, n + 1) mp[b[i]].emplace_back(i);
    for (int i = n; i >= 1; i--) {
        auto it = mp.find(a[i]);
        if(it == mp.end() || it->second.empty()) {
            cout << -1 << endl;
            return;
        }
        a[i] = it->second.back();
        it->second.pop_back();
    }
    Fenwick fen(n);
    int ans = 0;
    fore(i, 1, n + 1) {
        fen.add(a[i], 1);
        ans += i - fen.query(a[i]);
    }
    cout << ans << endl;
}
```
