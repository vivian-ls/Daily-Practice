#### [K. Kanto To Johto](https://codeforces.com/gym/105833/problem/K)

**题意：** 给出一个有n个点，m条边的图，不保证从1号点可以到达所有的点，每条边有一个权值，多次经过一条边只需要付款一次，如果付款次数超过k，那么你只需要付最小的那k个，问最少你需要付多少钱

第一种：次数不超过k，那就是一个dj就可以解决，但是超过k次呢，这种情况下我们不如把所有能走的边全部走一遍，最后输出最小的k个的和就行

问题在于处理很麻烦，不一定所有边都能到达，所以要用到并查集

```cpp[]
void solve(){
    int n, m, k;
    cin >> n >> m >> k;
    vector<array<int, 3>> edge(m + 1);
    vector<vector<pii>> p(n + 1);
    int u, v, w;
    DSU dsu(n);
    fore(i, 1, m + 1) {
        cin >> u >> v >> w;
        edge[i] = {u, v, w};
        p[u].emplace_back(v, w);
        p[v].emplace_back(u, w);
        dsu.merge(u, v);
    }
    vector<int> ch;
    fore(i, 1, m + 1) {
        auto [u, v, w] = edge[i];
        if(dsu.find(u) == dsu.find(1))
            ch.emplace_back(w);
    }
    int ans = 0;
    sort(ch.begin(), ch.end());
    fore(i, 0, min(k + 1, (int)ch.size())) {
        if(i < k) ans += ch[i];
    }

    vector<int> dis(n + 1, inf), vis(n + 1, false);
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    pq.emplace(0, 1);
    dis[1] = 0;
    while(!pq.empty()) {
        auto [d, s] = pq.top();
        pq.pop();
        if(vis[s]) continue;
        vis[s] = true;
        for(auto[to, w] : p[s]) {
            if(dis[to] <= d + w) continue;
            dis[to] = d + w;
            pq.emplace(dis[to], to);
        }
    }
    ans = min(ans, dis[n]);
    cout << ans << endl;
}
```

#### [C. Chimchar Defense](https://codeforces.com/gym/105833/problem/C)

**题意：** 现在有n个地点有Piplup和Chimchar，每个C的生命值为h[i], P释放技能伤害为d[i]，代价为c[i]，每个技能可以对包括自己在内的左边所有的C造成伤害，最终的成果为总的伤害减去总花费，问这个最大值是多少

n只有5000是容易想到dp的，还是写的太少了，定义dp[i][j]表示从i开始包括i累计伤害为j时最大的val值

1.选择当前的d[i]：dp[i][j + d[i]] = dp[i + 1][j] + min(j + d[i], h[i]) - cost[i];

2.不选当前的d[i]：dp[i][j] = dp[i + 1][j] + min(j, h[i]);

这里向前转移好一点，从后面转移过来还要考虑是否大于0，麻烦一点，并且这里5000并不是最大的边界，可能会漏情况，5000只是定义的时候的最大边界

后面fore(j, 0, 5001) dp[j] += min(j, h[i]);不能放到前面循环里面，不然会多加的

```cpp[]
void solve(){
    int n;
    cin >> n;
    vector<int> h(n + 1), d(n + 1), cost(n + 1);
    fore(i, 1, n + 1) cin >> h[i];
    fore(i, 1, n + 1) cin >> d[i];
    fore(i, 1, n + 1) cin >> cost[i];
    vector<int> dp(5005, -inf);
    dp[0] = 0;
    for (int i = n; i >= 1; i--) {
        for (int j = 5000; j >= 0; j--) {
            int nj = min(j + d[i], 5000ll);
            dp[nj] = max(dp[nj], dp[j] - cost[i]);
        }
        fore(j, 0, 5001) dp[j] += min(j, h[i]);
    }
    cout << *max_element(dp.begin() + 1, dp.end()) << endl;
}
```

