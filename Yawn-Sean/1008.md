#### [E. Rasta Thamaye Dilo](https://codeforces.com/gym/104679/problem/E)

**题意：** 给出一个数n，点的编号从2开始一直到n，当 $i | j$ 或者 $j | i$ 时ij之间有一条边，问你需要增加最少多少条边使得所有点连通

实际上就是找 $[\lfloor n / 2 \rfloor, n]$ 之间质数的个数，我们是用的队列实现的，但是没写好，没注意边界导致一直错，用前缀和可能更好

🔔查询队列或栈元素时要先检查是不是空的

```cpp[]
vector<bool> is(10000005, true);
vector<int> ans(10000005);
vector<int> prime;
void init(){
    is[0] = is[1] = false;
    fore(i, 2, 10000001) {
        if(is[i]) prime.emplace_back(i);
        for(int p : prime) {
            if(p * i > 10000000) break;
            is[p * i] = false;
            if(i % p == 0) break;
        }
    }
    queue<int> q;
    fore(i, 2, 10000001) {
        if(is[i]) q.push(i);
        else if(!q.empty() && i == q.front() * 2) q.pop();
        ans[i] = q.size();
        if(!q.empty() && q.front() == 2)
            ans[i] -= 1;
    }
}

void solve(){
    int n;
    cin >> n;
    cout << ans[n] << endl;
}
```

#### [F. Lucky Seats](https://codeforces.com/gym/104679/problem/F)

**题意：** 给出一个a, b，你需要找出一个最长的序列，使得序列中的所有的数 '|' 起来结果是a，'^'结果是a，不存在输出-1

不妨先看看什么时候是-1，a的某位上是0，但是b上是1肯定就不行，因为或操作时不会丢失1的，还有一种就是a只有一个1，此时如果b是0的话，我们也是凑不出来的

这种多个条件的可以先试试满足一个条件再说，所有数或起来最后是a，那这些数只要二进制位是a的子集就行。怎么调整最后异或是b呢，可以发现最后结果是0就不用调整了，如果不是0，那么就从序列中把剩下的这个数减掉，因为剩下的数一定是可以取得到的

```cpp[]
void solve(){
    int a, b;
    cin >> a >> b;
    if((a | b) != a || ((a & -a) == a && b == 0 && a)) {
        cout << -1 << endl;
        return;
    }
    vector<int> ans;
    fore(i, 0, a + 1) {
        if((a & i) == i) {
            ans.emplace_back(i);
            b ^= i;
        }
    }
    int len = ans.size();
    if(b == 0) b = -1;
    else len -= 1;
    cout << len << endl;
    for(int x : ans) if(x != b) cout << x << ' ';
    cout << endl;
}
```
