#### [D. Triple Sword Strike](https://codeforces.com/gym/103855/problem/D)

**题意：** 二维平面上有n个怪物，你可以在任意行或者列斩击三次，问最后杀死的所有怪物的val值的和最大是多少

最后只可能有3 + 0和2 + 1两种情况，第一种很简单，第二种可以枚举少的哪一行，事先维护好每一列的总值，枚举(坐标编号)的过程中就把对应的列的总值减掉，这里就有了一个优化

我们没有必要去枚举所有的列，如果我们修改了x列的值，枚举最多x+2列就够了，所以最后时间复杂度是O(n)的，并不是很大

```cpp
void solve(){
    int n;
    cin >> n;
    vector<int> x(n + 1), y = x, val = x;
    fore(i, 1, n + 1) cin >> x[i] >> y[i] >> val[i];

    auto cal = [&]() -> int
    {
        vector<int> cnt(1000005, 0);
        fore(i, 1, n + 1) cnt[y[i]] += val[i];
        vector<int> order(1000005);
        iota(order.begin(), order.end(), 0);
        sort(order.begin() + 1, order.end(), [&](int a, int b)
             { return cnt[a] > cnt[b]; });
        int ans = cnt[order[1]] + cnt[order[2]] + cnt[order[3]];

        map<int, vector<int>> mp;
        fore(i, 1, n + 1) {
            mp[x[i]].emplace_back(i);
        }

        for(auto[x, id] : mp) {
            int cur = 0;
            for(int i : id) {
                cnt[y[i]] -= val[i];
                cur += val[i];
            }
            int v1 = 0, v2 = 0;
            fore(i, 1, id.size() + 2 + 1){
                int tmp = cnt[order[i]];
                if(tmp > v1) v2 = v1, v1 = tmp;
                else if(tmp > v2) v2 = tmp;
            }
            ans = max(ans, cur + v1 + v2);
            for(int i : id) {
                cnt[y[i]] += val[i];
            }
        }
        return ans;
    };
    int ans = 0;
    ans = max(ans, cal());
    fore(i, 1, n + 1) swap(x[i], y[i]);
    ans = max(ans, cal());
    cout << ans << endl;
}
```

#### [E. RPS Bubble Sort](https://codeforces.com/gym/103855/problem/E)

**题意：** 现在对一个序列进行石头剪刀布排序，规则为如果s[i] > s[i + 1]就swap(s[i], s[i+1])，每次操作一次对所有的 $i \in [1, n - ]$ 进行，问T次操作后序列是怎样的

我们要搞清楚为什么问题显得很麻烦，明显就是三个种类太多了，可以先看看两种的

例如只有'S'(剪刀)和'P'(布)，可以发现每次循环就是把所有的S移动到前一个S的后面，并且最前面一定增加一个S(如果可以的话)，这种是非常好计算的，我们就可以一次只看两种元素的区间，下一段区间开始一定是'R'，但是当前一定是'S'结尾，跟后面完全没关系了，所以这么做是正确的

这里处理区间的技巧是先把所有的都设置为'S'，之后再修改'P'，注意边界即可

```cpp
void solve(){
    int n, t;
    cin >> n >> t;
    string s;
    cin >> s;
    s = " " + s;
    set<char> st;

    auto cal = [&](int l, int r) -> void {
        map<char, vector<int>> mp;
        fore(i, l, r) {
            mp[s[i]].emplace_back(i);
        }
        if(mp.find('P') == mp.end()) {
            fore(i, l, r) s[i] = 'R';
            int cur = l - 1;
            for(int x : mp['S']) {
                cur = max(cur + 1, x - t);
                s[cur] = 'S';
            }
        }
        if(mp.find('R') == mp.end()) {
            fore(i, l, r) s[i] = 'S';
            int cur = l - 1;
            for(int x : mp['P']) {
                cur = max(cur + 1, x - t);
                s[cur] = 'P';
            }
        }
        if(mp.find('S') == mp.end()) {
            fore(i, l, r) s[i] = 'P';
            int cur = l - 1;
            for(int x : mp['R']) {
                cur = max(cur + 1, x - t);
                s[cur] = 'R';
            }
        }
    };
    int l = 1;
    fore(i, 1, n + 1) {
        st.insert(s[i]);
        if(st.size() == 3){
            cal(l, i);
            l = i;
            st = {s[i]};
        }
    }
    cal(l, n + 1);
    cout << s.substr(1, n + 1) << endl;
}
```
