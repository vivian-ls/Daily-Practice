#### [C. Feeding Beavers](https://codeforces.com/gym/105822/problem/C)  🔥

**题意：** 现在有n只河狸需要食物，你有价值从 $1 ~ 2n$ 的食物，你需要给没人分配两个食物，使得至少后面的河狸得到的食物价值比前面的大，并且每个河狸的食物符合给定的奇偶条件(由一个字符串给出)，'E'代表偶数，'O'代表奇数

偶数只能由两个偶数或者两个奇数组成，所以我们可以贪心的去构造，如果是奇数那么从奇数和偶数能选的最小的各选一个，如果是偶数的话只有当已经选的偶数的个数比奇数多一个时才选两个奇数，否则就选两个偶数(反过来也可以，这里只是一种情况)，这样就完成啦

```cpp[]
void solve(){
    int n;
    cin >> n;
    string s;
    cin >> s;
    s = " " + s;
    vector<pii> ans(n + 1);
    int odd = 1, even = 1;
    fore(i, 1, n + 1) {
        if(s[i] == 'O') {
            ans[i] = {odd++ * 2 - 1, even++ * 2};
        }else{
            if(even < odd) ans[i] = {even++ * 2, even++ * 2};
            else ans[i] = {odd++ * 2 - 1, odd++ * 2 - 1};
        }
    }
    int flag = true;
    fore(i, 2, n + 1) {
        int s1 = ans[i].first + ans[i].second;
        int s2 = ans[i - 1].first + ans[i - 1].second;
        if(s2 > s1)
            flag = false;
    }
    fore(i, 1, n + 1) {
        if(ans[i].first > n * 2 || ans[i].second > n * 2)
            flag = false;
    }
    if(flag) {
        cout << "Yes" << endl;
        fore(i, 1, n + 1) cout << ans[i].first << ' ' << ans[i].second << endl;
    }else{
        cout << "No" << endl;
    }
}
```

#### [D. Beaverland](https://codeforces.com/gym/105822/problem/D)

**题意：** 给出一个n个点m条边的图，然后给出k的点的序列，你可以在任意的两个城市之间条件路径，所有路径长度都是1，只有对于所有的 i 有 $dis(1, i) > dis(1, i - 1)$
时河狸才是开心的，你能否通过添加路径使其开心，如果可以输出方案

这种题目有一种思考方式就是假设当前我们有了一个已经满足条件了的图，我们再添加 $(1, x1), (x1, x2)...$ 这些边之后不会影响结果，新添加的边如果有影响那么必须是从 $x1$ 到 $x2$ ，但是这样一定会让路径变长，之后我们再删除之前构造的所有路，发现条件仍然是成立的

只需要检查按顺序添加边之后是否合法即可，注意 $x1$ 可能是 $1$ ，所以要特判一下

🔔这里求最短路一个队列就行，不用跑dj

```cpp[]
void solve(){
    int n, m, k;
    cin >> n >> m >> k;
    vector<int> a(k);
    fore(i, 0, k) cin >> a[i];
    vector<vector<int>> p(n + 1);
    int u, v;
    fore(i, 1, m + 1) {
        cin >> u >> v;
        p[u].emplace_back(v);
        p[v].emplace_back(u);
    }
    int cur = 1;
    for(int x : a) {
        if(x != cur) {
            p[x].emplace_back(cur);
            p[cur].emplace_back(x);
        }
        cur = x;
    }
    vector<int> dis(n + 1, -1);
    dis[1] = 0;
    queue<int> q;
    q.emplace(1);
    while(!q.empty()) {
        int s = q.front(); q.pop();
        for(int to : p[s]) {
            if(dis[to] == -1) {
                dis[to] = dis[s] + 1;
                q.emplace(to);
            }
        }
    }
    int flag = true;
    fore(i, 1, k) {
        if(dis[a[i]] <= dis[a[i - 1]])
            flag = false;
    }
    if(flag) {
        cout << (a[0] == 1 ? k - 1 : k) << endl;
        int cur = 1;
        for(int x : a) {
            if(cur != x) cout << cur << ' ' << x << endl;
            cur = x;
        }
    }else{
        cout << -1 << endl;
    }
}
```
