#### [B.Impossible to guess](https://codeforces.com/gym/100488/problem/B)

**题意：** 给出一个n的随机摆列，你每次都可以询问一个区间，然后会给出这个区间所有数按升序排列的结果，你需要再(n + 1) / 2次询问后输出结果

奇数的时候我们对最后一个单独问一次就行，所以我们可以只考虑偶数的情况

可以发现我们必须一次询问得到两个数的位置，于是我们有一个想法是先询问哪些数再前半段，之后从 (n/2, n/2+1) 这一对逐渐往外扩大即可，我们每次都能得到两个新的数，并且可以知道哪一个再前面，这样就满足要求了，至于最后一次[1, n]的不用询问，我们本身就知道

**tips:** 想不出来可以先从小数据开始

```cpp[]
void solve(){
    int n, m;
    int tmp;
    cin >> n;
    m = n;
    vector<int> ans(n + 1);
    vector<int> vis(n + 1, false);
    if(n == 1) {
        cout << "A" << ' ' << 1 << endl;
        return;
    }
    if(n % 2 == 1) {
        cout << "Q" << ' ' << n << ' ' << n << endl;
        cin >> tmp;
        ans[n] = tmp, vis[tmp] = true;
        m -= 1;
    }
    set<int> pre;
    cout << "Q" << ' ' << 1 << ' ' << m / 2 << endl;
    fore(i, 1, m / 2 + 1) {
        cin >> tmp;
        pre.insert(tmp);
    }
    for (int i = m / 2; i >= 1; i--) {
        int l = i, r = m - i + 1;
        int a = -1, b = -1;
        if(i != 1) {
            cout << "Q" << ' ' << l << ' ' << r << endl;
            fore(k, l, r + 1) {
                cin >> tmp;
                if(vis[tmp]) continue;
                vis[tmp] = true;
                if(a == -1) a = tmp;
                else b = tmp;
            }
        }else{
            fore(i, 1, n + 1) {
                if(vis[i]) continue;
                vis[i] = true;
                if(a == -1) a = i;
                else b = i;
            }
        }
        if(pre.count(a)) ans[l] = a, ans[r] = b;
        else ans[l] = b, ans[r] = a;
    }
    cout << "A" << ' ';
    fore(i, 1, n + 1) cout << ans[i] << " \n"[i == n];
}
```

#### [L. Two Heads Are Better](https://codeforces.com/gym/100488/problem/L)

**题意：** 给出一个数组和两个指针，现在有三种操作，1：将左指针或者右指针左移或右移，2：翻转两个指针间的字母(reverse)，3：输出左或右指针的值

第一反应肯定是打标记，但是标记该怎么搞？

开始不应该把问题放在如何处理翻转上，而是看我们左移右移怎么去操作，也就是说我们知道l, r指针的左右两侧都是谁，之后就可以维护了。左右都用一个栈维护就行，实际数组更好一点，中间用双端队列，同时记录中间数组是否被翻转过，因为翻转后指针移动而添加到前面的字母会加到后面，这样就可以轻松维护了

```cpp[]
void solve(){
    int n, l, r, m;
    int is = 1;
    char op, a, b;
    cin >> n >> l >> r;
    string s;
    cin >> s;
    s = " " + s;
    vector<char> left(s.begin() + 1, s.begin() + l);
    vector<char> right(s.begin() + r + 1, s.end());
    deque<char> mid(s.begin() + l, s.begin() + r + 1); 
    reverse(right.begin(), right.end());
    cin >> m;
    fore(i, 1, m + 1) {
        cin >> op;
        if(op == 'S') {
            cin >> a >> b;
            if(a == 'L') {
                if(b == 'L') {
                    char tmp = left.back();
                    left.pop_back();
                    if(is) mid.push_front(tmp);
                    else mid.push_back(tmp);
                }else{
                    char tmp;
                    if(is) tmp = mid.front(), mid.pop_front();
                    else tmp = mid.back(), mid.pop_back();
                    left.push_back(tmp);
                }
            }else{
                if(b == 'L') {
                    char tmp;
                    if(is) tmp = mid.back(), mid.pop_back();
                    else tmp = mid.front(), mid.pop_front();
                    right.push_back(tmp);
                }else{
                    char tmp = right.back();
                    right.pop_back();
                    if(is) mid.push_back(tmp);
                    else mid.push_front(tmp);
                }
            }
        } else if(op == 'R') {
            is ^= 1;
        } else{
            char tmp;
            cin >> tmp;
            if((tmp == 'L' && is) || (tmp == 'R' && !is)) cout << mid.front();
            else cout << mid.back();
        }
    }
}
```



