#### [D. John and President](https://codeforces.com/gym/104328/problem/D)

**题意：** 给出一颗有n个节点的数，每个点有一个权值，你需要输出能否找到一条链，链上的所有数都可以被一个常数x整除，并且这个链的长度大于 n/2，如果找不到输出no，找到输出yes

开始我想的是真的找到这个整数x，但是没必要，对所有数分解质因数后，分解出来的次数和有多少个质因数有交集都无所谓，只要有就行，所以只需要对每个质数进行判断，看看有这个质数的数能否连成一个符合要求的链

```cpp[]
void solve(){
    int n;
    cin >> n;
    vector<int> val(n + 1);
    fore(i, 1, n + 1) cin >> val[i];
    vector<vector<int>> adj(n + 1);
    int u, v;
    fore(i, 1, n) {
        cin >> u >> v;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    map<int, int> mp;
    fore(i, 1, n + 1) {
        int v = val[i];
        for(int p : prime) {
            if(p * p > v) break;
            if(v % p == 0) {
                while(v % p == 0) v /= p;
                mp[p] += 1;
            }
        }
        if(v > 1) mp[v] += 1;
    }
    vector<int> dp(n + 1);
    int p, max_len = 0;
    auto dfs = [&](auto &&dfs, int s, int fa) -> void
    {
        dp[s] = (val[s] % p == 0);
        int first = 0, second = 0;
        for(int to : adj[s]) {
            if(to == fa) continue;
            dfs(dfs, to, s);
            if(dp[to] > first) {
                second = first, first = dp[to];
            }else if(dp[to] > second) {
                second = dp[to];
            }
        }
        if(dp[s] == 0) return;
        dp[s] += first;
        max_len = max(max_len, dp[s] + second);
    };
    for(auto[cur, cnt] : mp) {
        if(cnt <= n / 2) continue;
        max_len = 0, p = cur;
        dfs(dfs, 1, -1);
        if(max_len > n / 2) {
            cout << "Yes" << endl;
            return;
        }
    }
    cout << "No" << endl;
}
```

