#### [D. DiviDuelo](https://codeforces.com/gym/105053/problem/D)

**题意：** 给出一个数n，将他的所有因数都列出来，两人轮流选数，如果第一个人最后选的所有的数 $gcd$ 起来不是1，那么他就赢了，否则另外一个获胜，输出第一个人是否必胜

题目要求选择因数，肯定要用到质因数分解来做，分解出质因数以及它的次数后我们就可以找到所有的因数

我们不妨先想一想有哪些简单的情况，后面说的质因数不包含1

质因数个数为1时：可选的数字并不多，有 $1, p, p^2 ...$ 第二个只需要让第一个选到1就行，所以这里就只和奇偶有关

为2的时候呢： $1, p, q, pq$ 这里是次数都是1的时候可选的数，可以发现是必胜的，先选择 $pq$ 后随便选一个都可以获胜，但是次数不是1呢？这时候就可能有 $1, p, q, p^2, pq, p^2q$ ，我们可以找出两对数 $(1, q), (p, p^2)$ 我们一定可以让第一个人选择两组中的数各一个，这样就是必输的

更多呢？发现甚至比2个更简单，我们只需要让第一个人选到两个互质的数就行了，不难想到此时一定可以做到

📖如何分解质因子？如果存在大于 $\sqrt N$ 的质因子，它一定是N，只有找质因子可以这样算

🔔后面统计pws奇偶的时候没有考虑1，所以奇偶条件是反过来的

```cpp[]
void solve(){
    int n;
    cin >> n;
    if(n == 1) {
        cout << "N" << endl;
        return;
    }
    vector<int> pws;
    for (int i = 2; i <= 1'000'000; i++) {
        if(n % i == 0) {
            pws.emplace_back(0);
            while(n % i == 0) {
                n /= i;
                pws.back()++;
            }
        }
    }
    if(n > 1) pws.emplace_back(1);
    if(pws.size() > 2) cout << "N" << endl;
    else if(pws.size() == 1) cout << "NY"[pws[0] & 1] << endl;
    else if(max(pws[0], pws[1]) == 1) cout << "Y" << endl;
    else cout << "N" << endl;
}
```

#### [G. Just Visiting Relatives](https://codeforces.com/gym/105022/problem/G)

**题意：** 给出两个数n和k，接着给出两个长度为n的数组a, b，矩阵 $A_{(i, j)} = a[i] * b[i]$ ，输出最后 $A^K$ 的结果
