#### [B.Impossible to guess](https://codeforces.com/gym/100488/problem/B)

**题意：** 给出一个n的随机摆列，你每次都可以询问一个区间，然后会给出这个区间所有数按升序排列的结果，你需要再(n + 1) / 2次询问后输出结果

奇数的时候我们对最后一个单独问一次就行，所以我们可以只考虑偶数的情况

可以发现我们必须一次询问得到两个数的位置，于是我们有一个想法是先询问哪些数再前半段，之后从 (n/2, n/2+1) 这一对逐渐往外扩大即可，我们每次都能得到两个新的数，并且可以知道哪一个再前面，这样就满足要求了，至于最后一次[1, n]的不用询问，我们本身就知道

**tips:** 想不出来可以先从小数据开始

```cpp[]
void solve(){
    int n, m;
    int tmp;
    cin >> n;
    m = n;
    vector<int> ans(n + 1);
    vector<int> vis(n + 1, false);
    if(n == 1) {
        cout << "A" << ' ' << 1 << endl;
        return;
    }
    if(n % 2 == 1) {
        cout << "Q" << ' ' << n << ' ' << n << endl;
        cin >> tmp;
        ans[n] = tmp, vis[tmp] = true;
        m -= 1;
    }
    set<int> pre;
    cout << "Q" << ' ' << 1 << ' ' << m / 2 << endl;
    fore(i, 1, m / 2 + 1) {
        cin >> tmp;
        pre.insert(tmp);
    }
    for (int i = m / 2; i >= 1; i--) {
        int l = i, r = m - i + 1;
        int a = -1, b = -1;
        if(i != 1) {
            cout << "Q" << ' ' << l << ' ' << r << endl;
            fore(k, l, r + 1) {
                cin >> tmp;
                if(vis[tmp]) continue;
                vis[tmp] = true;
                if(a == -1) a = tmp;
                else b = tmp;
            }
        }else{
            fore(i, 1, n + 1) {
                if(vis[i]) continue;
                vis[i] = true;
                if(a == -1) a = i;
                else b = i;
            }
        }
        if(pre.count(a)) ans[l] = a, ans[r] = b;
        else ans[l] = b, ans[r] = a;
    }
    cout << "A" << ' ';
    fore(i, 1, n + 1) cout << ans[i] << " \n"[i == n];
}
```

#### [L. Two Heads Are Better](https://codeforces.com/gym/100488/problem/L)

**题意：** 给出一个数组和两个指针，现在有三种操作，1：将左指针或者右指针左移或右移，2：翻转两个指针间的字母(reverse)，3：输出左或右指针的值

第一反应肯定是打标记，但是标记该怎么搞？

开始不应该把问题放在如何处理翻转上，而是看我们左移右移怎么去操作，也就是说我们知道l, r指针的左右两侧都是谁，之后就可以维护了。左右都用一个栈维护就行，实际数组更好一点，中间用双端队列，同时记录中间数组是否被翻转过，因为翻转后指针移动而添加到前面的字母会加到后面，这样就可以轻松维护了

```cpp[]
void solve(){
    int n, l, r, m;
    int is = 1;
    char op, a, b;
    cin >> n >> l >> r;
    string s;
    cin >> s;
    s = " " + s;
    vector<char> left(s.begin() + 1, s.begin() + l);
    vector<char> right(s.begin() + r + 1, s.end());
    deque<char> mid(s.begin() + l, s.begin() + r + 1); 
    reverse(right.begin(), right.end());
    cin >> m;
    fore(i, 1, m + 1) {
        cin >> op;
        if(op == 'S') {
            cin >> a >> b;
            if(a == 'L') {
                if(b == 'L') {
                    char tmp = left.back();
                    left.pop_back();
                    if(is) mid.push_front(tmp);
                    else mid.push_back(tmp);
                }else{
                    char tmp;
                    if(is) tmp = mid.front(), mid.pop_front();
                    else tmp = mid.back(), mid.pop_back();
                    left.push_back(tmp);
                }
            }else{
                if(b == 'L') {
                    char tmp;
                    if(is) tmp = mid.back(), mid.pop_back();
                    else tmp = mid.front(), mid.pop_front();
                    right.push_back(tmp);
                }else{
                    char tmp = right.back();
                    right.pop_back();
                    if(is) mid.push_back(tmp);
                    else mid.push_front(tmp);
                }
            }
        } else if(op == 'R') {
            is ^= 1;
        } else{
            char tmp;
            cin >> tmp;
            if((tmp == 'L' && is) || (tmp == 'R' && !is)) cout << mid.front();
            else cout << mid.back();
        }
    }
}
```

#### [D. Sum and Or](https://codeforces.com/gym/106042/problem/D)

**题意：** 给出一个长度位n的数组以及一个x和y，Alice和Bob轮流选一个数，Alice使a[i] = a[i] | x并且最后的总和最小，Bob使a[i] = ai[] & y且最后的总和最大，两人都按照目前最优的情况操作，问最后数组和是多少

我们如果枚举Alice的选择，那么只要可以快速得出Bob的最优解就行了

这个明显可以做到，对于除了Alice选的那一个，可以用一个前缀和后缀维护出来，最后Alice的那个单独算一次就行，统计最小值

```cpp[]
void solve(){
    int n, x, y;
    cin >> n >> x >> y;
    vector<int> a(n + 1);
    int sum = 0, ans = inf;
    fore(i, 1, n + 1) {
        cin >> a[i];
        sum += a[i];
    }
    vector<int> pre(n + 2, -inf), suf(n + 2, -inf);
    fore(i, 1, n + 1) 
        pre[i] = max(pre[i - 1], (a[i] & y) - a[i]);
    for (int i = n; i >= 1; i--)
        suf[i] = max(suf[i + 1], (a[i] & y) - a[i]);
    fore(i, 1, n + 1) {
        int tmp = sum;
        tmp += (a[i] | x) - a[i];
        int maxn = max(pre[i - 1], suf[i + 1]);
        maxn = max(maxn, ((a[i] | x) & y) - (a[i] | x));
        tmp += maxn;
        ans = min(ans, tmp);
    }
    cout << ans << endl;
}
```

#### [C. Trivial Problem](https://codeforces.com/gym/106043/problem/C)

今天第一个自己写的题，好耶！

**题意：** 给出一个有n个数的数组，定义f(k)位所有长度位k的子数组中最大值合起来去MEX的值，你需要输出所有的 f(x), $x \in [1, n]$ 

思考对于数组中的每个元素，再子序列长度为多少时这个数能在最后被保留，这个可以用单调栈维护，之后我们从小的开始遍历，后面的数能使其保留的最大的k一定不能比前面的大，因为再多也没意义了，所以这个数组是单调的，可以用二分找到最大的cnt[i] = k的下标

```cpp[]
void solve(){
    int n;
    cin >> n;
    vector<int> a(n + 1);
    fore(i, 1, n + 1) cin >> a[i];
    vector<int> cnt(200005);
    vector<int> st(200005);
    int cur = 0;
    fore(i, 1, n + 1) {
        while(cur && a[i] > a[st[cur]]) {
            cnt[a[st[cur]]] = max(i - st[cur - 1] - 1, cnt[a[st[cur]]]);
            cur--;
        }
        st[++cur] = i;
    }
    for (int i = cur; i >= 1; i--) {
        cnt[a[st[i]]] = n - st[i - 1];
    }
    fore(i, 1, 200005) cnt[i] = min(cnt[i - 1], cnt[i]);
    fore(i, 1, n + 1) {
        int l = 0, r = 200005, mid;
        while(l < r) {
            mid = (l + r + 1) >> 1;
            if(cnt[mid] >= i) l = mid;
            else r = mid - 1;
        }
        if(cnt[l] >= i) cout << l + 1 << ' ';
        else cout << 0 << ' ';
    }
    cout << endl;
}
```

