[J. Characters Shift](https://codeforces.com/gym/106032/problem/J)

**题意：** 给出一个长度位n个数组，每个数介于1 ~ m之间，每次有两种操作，第一个是将每一个 a[i] = a[i] % m + 1，第二个数输出a[i]的值，一共q次操作

**知识点：** 环形数组如何处理

观察可以发现一个数最多只能增加到这个数后面第一个奇数的大小，所以我们只用维护每一个数后面第一个个数为奇数的数是谁就行，最后增加的值就是操做次数和下一个奇数间隔的小的哪一个

```cpp[]
void solve(){
    int n, m, q;
    cin >> n >> m >> q;
    vector<int> a(n + 1), cnt(m + 1);
    fore(i, 1, n + 1) {
        cin >> a[i];
        cnt[a[i]] ^= 1;
    }
    vector<int> nxt(m + 1, inf);
    fore(i, 1, m + 1) if (cnt[i]) nxt[i] = 0;
    for (int i = m - 1; i >= 1; i--)
        nxt[i] = min(nxt[i], nxt[i + 1] + 1);
    nxt[m] = min(nxt[m], nxt[1] + 1);
    for (int i = m - 1; i >= 1; i--)
        nxt[i] = min(nxt[i], nxt[i + 1] + 1);
    int op, x, t = 0;
    while(q--) {
        cin >> op;
        if(op == 1) t++;
        else{
            cin >> x;
            int ans = a[x] + min(t, nxt[a[x]]);
            cout << (ans - 1) % m + 1 << endl;
        }
    }
}
```
[C. Chess in 3D](https://codeforces.com/gym/105809/problem/C)

**题意：** 有一个三维的空间，长宽高为a, b, c，每个骑士可以攻击到从自身出发走一个"L"型的位置，此外里面还有一些点是被阻挡的，上面无法放置骑士，你需要放置最多的骑士并且他们不会通过一次移动相遇，输出最大骑士数量

**知识点：** 二分图，三维点的映射

首先这就是一个独立集问题，并且从(x + y + z)为奇数的位置只能跳到它为偶数的位置，也就是说可以根据这个将点分为两类，可以使用二分图

关键问题，怎么理解二分图？记住二分图的用法就是计算最大匹配，并且最小顶点覆盖 = 最大匹配，最大独立集 = 总数 - 最小覆盖数，这个把奇数点放左边偶数放右边没有那么玄乎，就是单纯为了不连反边，想一想最早学的婚配问题，不也是从一边连到另一边吗，所以这里不要想复杂了，这里也和最大匹配没关系，只是利用了结论利用了这个数，我们需要的数最大独立集！！！

计算最大独立集要先计算最大匹配所以才有了之前的误解，实际是很简单的了，然后就结束啦

最后有一个映射的技巧得说一说，由于我们是(1, 1)开始，所以f函数每个都要减一，因为我们压缩的内部还是(0, 0)开始的，第一个点编号就是0，我们后面加的1就是为了我们的1 index。记住内部原理就不会弄混了！

```cpp[]
class BP{
public:
    int n, m;
    vector<vector<int>> p;
    vector<int> vis, link;
    int t = 0;
    BP(int n, int m) : n(n), m(m), p(n + 1), vis(m + 1, false), link(m + 1, -1) {}
    void add(int u, int v) { p[u].emplace_back(v); }
    bool dfs(int l) {
        for(int r : p[l]) {
            if(vis[r] == t) continue;
            vis[r] = t;
            if(link[r] == -1 || dfs(link[r])){
                link[r] = l;
                return true;
            }
        }
        return false;
    }
    int match() {
        int ans = 0;
        fore(i, 1, n + 1) {
            ++t;
            ans += dfs(i);
        }
        return ans;
    }
};

void solve(){
    int a, b, c;
    cin >> a >> b >> c;
    int k, x, y, z;
    cin >> k;
    auto f = [&](int x, int y, int z) -> int {
        return ((x - 1) * b + (y - 1)) * c + (z - 1) + 1;
    };
    vector<bool> block(a * b * c + 5);
    fore(i, 0, k) {
        cin >> x >> y >> z;
        block[f(x, y, z)] = true;
    }
    vector<array<int, 3>> dir;
    fore(i, -2, 2 + 1) fore(j, -2, 2 + 1) {
        if(abs(i) + abs(j) == 3) {
            dir.push_back({0, i, j});
            dir.push_back({i, 0, j});
            dir.push_back({i, j, 0});
        }
    }
    int ans = a * b * c;
    BP bp(a * b * c, a * b * c);
    fore(x, 1, a + 1) fore(y, 1, b + 1) fore(z, 1, c + 1) {
        if(block[f(x, y, z)]) {
            ans--;
        }else{
            if((x + y + z) % 2 == 1) {
                for(auto t : dir) {
                    int xx = x + t[0], yy = y + t[1], zz = z + t[2];
                    if(xx < 1 || xx > a || yy < 1 || yy > b || zz < 1 || zz > c) continue;
                    if(block[f(xx, yy, zz)]) continue;
                    bp.add(f(x, y, z), f(xx, yy, zz));
                }
            }
        }
    }
    cout << ans - bp.match() << endl;
}
```








