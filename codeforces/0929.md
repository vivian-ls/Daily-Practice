[I. Map Coloring](https://codeforces.com/gym/100488/problem/I?__cf_chl_tk=4.CQybNR5PpxasNBj5ez5FDguhoOV_q0ac2V7aS92HY-1759157221-1.0.1.1-8EwleBb6KEluvHPwkSiSHDyUqV6O423_iID23KjMbQ4)

**题意：** 给出一个有n个点，m条边的图，要求最多用k种颜色给每个点染色，但是必须保证两个点颜色不同当前仅当两点之间有一条边，问能否成功涂色，成功输出方案，否则输出-1

开始我自己写的时候想到了说吧点之间没有边的搞成一个连通块，但是由于写的太烂而且也不对直接就错了，正确方式是构造反图。用临界矩阵就可以轻松维护，把p[i][j] = 0的当成有边不就行啦，我开始想的是边涂色边判断涂的这个是否满足，但是这样会非常麻烦，我写的是看被涂的点是否已经涂过，原理是一个点不能有两种颜色，但是是不对的，看看样例3就明白了

所以我们不如就先按照最好的方式填，最后再判断是否合法就行

```cpp[]
void solve(){
    int n, m, k;
    cin >> n >> m >> k;
    int u, v;
    vector<vector<int>> p(n + 1, vector<int>(n + 1));
    fore(i, 1, m + 1) {
        cin >> u >> v;
        p[u][v] = p[v][u] = 1;
    }
    vector<int> col(n + 1);
    int cur = 0;
    auto dfs = [&](auto &&dfs, int s) -> void
    {
        col[s] = cur;
        fore(i, 1, n + 1) if (!p[s][i] && !col[i]) dfs(dfs, i);
    };
    fore(i, 1, n + 1) {
        if(col[i]) continue;
        cur++;
        dfs(dfs, i);
    }
    int flag = true;
    if(cur > k) flag = false;
    fore(i, 1, n + 1) fore(j, 1, n + 1) if (p[i][j] && col[i] == col[j]) flag = false;
    if(flag) {
        fore(i, 1, n + 1) cout << col[i] << " \n"[i == n];
    }else {
        cout << -1 << endl;
    }
}
```
[K. Two Pirates](https://codeforces.com/gym/100488/problem/K?__cf_chl_tk=sazLqpwMVOitllnM4Hr3eLWx.0vQ4Z_7Kb3dzEQ.Hwc-1759162878-1.0.1.1-70leIC8NDfmhU_7Qzq3xWPYi6gf7vjYAwG_YPa7kimY)

**题意：** 现在面前有n个宝藏，每个都有其对应的价值，你可以先选一个，之后另外一个人一定会选择最靠前的那一个，问最后得到的最大价值是多少

开始有一点碰到了题解的意思，但是没发现关键点没写出来。。。

就是有一个点是如果当前是奇数位可以多拿一个，那么就拿过来，偶数的时候判断我们拿的最小的是不是比这个新的大，更优就换一下，因为我们把拿的机会从前面移到后面是一定可以达成的

```cpp[]
void solve(){
    int n, sum = 0;
    cin >> n;
    vector<int> val(n + 1);
    fore(i, 1, n + 1) {
        cin >> val[i];
        sum += val[i];
    }
    int ans = 0;
    priority_queue<int, vector<int>, greater<int>> pq;
    fore(i, 1, n + 1) {
        if(i & 1) {
            ans += val[i];
            pq.push(val[i]);
        }else{
            if(val[i] > pq.top()) {
                ans -= pq.top();
                pq.pop();
                ans += val[i];
                pq.push(val[i]);
            }
        }
    }
    cout << ans << ' ' << sum - ans << endl;
}
```



