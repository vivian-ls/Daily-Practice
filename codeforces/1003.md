#### [J. Jovial Jaunt](https://codeforces.com/gym/105012/problem/J)

**题意：** 给出一个有n个点的树，每一个点有一个权值，对于函数f(x)有如下定义

-   $f(x_1) = x_1$.
-   $f(x_1, x_2) = \max{(x_1, x_2)} + \lfloor\sqrt{\min{(x_1, x_2)}}\rfloor$.
-   For $k > 2$, $f(x_1, x_2, \ldots, x_k) = f(f(x_1,\ldots, x_{k-1}), x_k)$.

你可以任意选择起点和终点，问最后可以得到的 $f(x_1, x_2, ...)$ 最大的值是多少？

开始我想的是经过val最大的那个点，然后向上下两边扩展，但是并不对，因为不是选了最大的就是最好的，这种给出路径权值要求最大化值的问题就是经典换根dp

首先预处理dfs统计dp1[i]，表示在i的子树中的任意一个点向上走到i可以得到的最大值，注意这里i是最后一个数字，这样我们才能够进行后面的转移。之后第二次dfs处理出dp2[i]表示删除以i为根的子树但是保留i后，新的根为i的类似dp1的值，类似一上一下。但是这里的dp2[i]可以来源于父亲也可以来源于当前节点的子节点，所以我们需要记录第一大的和第二大的，当我们遍历到第一大的子节点时就要用到第二大的值了。然后就做出来啦

```cpp[]
int f(int x, int y) {
    return max(x, y) + (int)sqrt(min(x, y));
}

void solve(){
    int n;
    cin >> n;
    vector<int> val(n + 1);
    fore(i, 1, n + 1) cin >> val[i];
    vector<vector<int>> p(n + 1);
    int u, v;
    fore(i, 1, n) {
        cin >> u >> v;
        p[u].emplace_back(v);
        p[v].emplace_back(u);
    }
    vector<int> dp1(n + 1), dp2 = dp1;
    auto dfs1 = [&](auto &&dfs1, int s, int fa) -> void
    {
        dp1[s] = val[s];
        for(int to : p[s]) {
            if(to == fa) continue;
            dfs1(dfs1, to, s);
            dp1[s] = max(dp1[s], f(val[s], dp1[to]));
        }
    };
    dfs1(dfs1, 1, -1);
    dp2[1] = val[1];
    auto dfs = [&](auto &&dfs, int s, int fa) -> void
    {
        int first = dp2[s], second = 0;
        for(int to : p[s]) {
            if(to == fa) continue;
            int tmp = f(dp1[to], val[s]);
            if(tmp > first) second = first, first = tmp;
            else if(tmp > second) second = tmp;
        }
        for(int to : p[s]) {
            if(to == fa) continue;
            int tmp = f(dp1[to], val[s]);
            if(tmp == first) dp2[to] = f(second, val[to]);
            else dp2[to] = f(first, val[to]);
            dfs(dfs, to, s);
        }
    };
    dfs(dfs, 1, -1);
    cout << max(*max_element(dp1.begin(), dp1.end()), *max_element(dp2.begin(), dp2.end())) << endl;
}
```

