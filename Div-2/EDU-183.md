#### [D. Inversion Value of a Permutation](https://codeforces.com/contest/2145/problem/D)

**题意：** 给出两个数n, k，问能否构造出一个数列使得满足下面条件的点对的数量恰好是k个，对于[l, r]在这之间存在一个逆序对

直接构造不太好想就可以考虑反向构造，我们开始让这样的l, r对数最多，之后再减少对数

这样构造可以发现我们翻转一段区间是独立的，开始数组是从大到小排列的，前面怎么排都不会影响后面，这样就好办了，我们只需要分块就行了

定义dp[i][j]表示还剩下i个位置是否可以凑出j个递增区间(这时候维护的信息反过来了，因为我们在反向构造)，第二位是一个bitset用于快速合并集合，可以看一看dp的递推式子，挺奇妙的

怎么输出结果呢？可以发现我们分的块和它在哪个位置没有关系，只关心块是怎么分的，所以从块数最小的1开始一直找，没找到都加大块数，找到就接着维持这个大小继续找，就类似于最后你分的块是这样的： 1, 2, 3, 3, 5... 你在找到一个大小是3的块之后肯定接着找3的

```cpp[]
vector<bitset<500>> dp(35);
void init(){
    dp[0][0] = 1;
    for (int i = 0; i <= 30; i++) {
        for (int j = 1; i + j <= 30; j++) {
            dp[i + j] |= dp[i] << (j * (j + 1) / 2);
        }
    }
}

void solve(){
    int n, k;
    cin >> n >> k;
    k = n * (n + 1) / 2 - k;
    if(dp[n][k] == 0) {
        cout << 0 << endl;
        return;
    }
    vector<int> ans;
    fore(i, 1, n + 1) {
        if(dp[n - i][k - i * (i + 1) / 2]) {
            k -= i * (i + 1) / 2;
            n -= i;
            fore(j, 1, i + 1) ans.emplace_back(n + j);
            i--;
        }
    }
    for(int x : ans) cout << x << ' ';
    cout << endl;
}
```
