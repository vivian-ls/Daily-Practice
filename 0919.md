[J. Jesting Jabberwocky](https://codeforces.com/gym/104059/problem/J)

**题意：** 你现在有n张扑克牌，其花色分别用 h, s, c, d 表示，每次操作可以选择一张牌将其插入到任意一个位置，问最少需要多少次操作可以使得相同花色的全部放在一起

直接思考交换哪几张牌肯定很复杂，我们不妨思考哪些牌是可以不动的，要知道这个自然就会想到我们先给出一个花色的顺序，开始一堆是方片，然后是红心，等等

就好比是找到一个序列使得其中的每个字母都满足给定的关系，可以用一个dp维护，dp[i]可以由所有 j < i 的dp[j]转移过来，复杂度也不大

需要注意的是开始给出的p字符串必须是字典序最小的排列，这样才能遍历所有情况

```cpp[]
void solve(){
    string s, p;
    p = "cdhs";
    cin >> s;
    int ans = 0;
    do{
        vector<int> dp(4, 0);
        for(char c : s) {
            fore(i, 0, 4) {
                if(p[i] == c) {
                    int tmp = 0;
                    fore(j, 0, i + 1) tmp = max(tmp, dp[j]);
                    dp[i] = tmp + 1;
                }
            }
        }
        int maxn = 0;
        fore(i, 0, 4) maxn = max(maxn, dp[i]);
        ans = max(ans, maxn);

    } while (next_permutation(p.begin(), p.end()));
    cout << s.length() - ans << endl;
}
```

[C. Sorting Subarrays](https://codeforces.com/gym/104182/problem/C)

**题意：给出一个数组，可以选择一个子段将里面所有数按递增排列，问经过一次操作最后可以得到多少种数组**

开始先思考到的就是什么样的l, r会得到不一样的结果，就是a[l]不是最小值，a[r]不是最大值的时候，如果有一个是最值，那么就没必要扩大这个区间

但是直接计算不是最值的个数属实不好算，但是我们可以使用容斥原理，先减去a[l]是区间最小值的区间个数和a[r]是区间最大值的区间个数，最后再加上两个都是最值的区间个数即可

这样就可以写啦，前面两个用单调栈都可以轻松解决，记住维护最大值区间用递减序列，维护最小值用递增序列！！！

关键的就是怎么维护两个都是最值的区间，这个固定l或者r去找另一个就行，必须明白的是要得到这个结果我们需要什么（以固定r为例）：我们的l从r开始一直往左边扩的时候这个a[l]的值要是一直减小的并且是区间最小值，而且这个选定的区间中不能有比a[r]更大的数，想一下单调栈存储的就是左边第一个比自己小的数，正是我们想要的，我们只需要二分一下这个l到r的区间是否包含比r更大的数就行，第一个比r更大的数再用一个递减单调栈就又可以维护了，到这里就解决问题啦

```cpp[]
void solve(){
    int n;
    cin >> n;
    vector<int> a(n + 1);
    fore(i, 1, n + 1) cin >> a[i];
    int ans = (n + 1) * n / 2 + 1;
    vector<int> st = {0};
    fore(i, 1, n + 1) {
        while(st.back() != 0 && a[i] >= a[st.back()])
            st.pop_back();
        ans -= i - st.back();
        st.push_back(i);
    }
    st = {n + 1};
    for (int i = n; i >= 1; i--) {
        while(st.back() != n + 1 && a[i] <= a[st.back()])
            st.pop_back();
        ans -= st.back() - i;
        st.push_back(i);
    }
    vector<int> st1 = {0}, st2 = {0};
    fore(i, 1, n + 1) {
        while(st1.back() != 0 && a[i] >= a[st1.back()])
            st1.pop_back();
        while(st2.back() != 0 && a[i] < a[st2.back()])
            st2.pop_back();
        int l = 0, r = st2.size() - 1, mid;
        while(l < r) {
            mid = (l + r + 1) >> 1;
            if(st2[mid] <= st1.back()) l = mid;
            else r = mid - 1;
        }
        ans += st2.size() - 1 - l + 1;
        st1.push_back(i);
        st2.push_back(i);
    }
    cout << ans << endl;
}
```
[C. Sorting Subarrays](https://codeforces.com/gym/104182/problem/C)

**题意：给出一个数组，可以选择一个子段将里面所有数按递增排列，问经过一次操作最后可以得到多少种数组**

开始先思考到的就是什么样的l, r会得到不一样的结果，就是a[l]不是最小值，a[r]不是最大值的时候，如果有一个是最值，那么就没必要扩大这个区间

但是直接计算不是最值的个数属实不好算，但是我们可以使用容斥原理，先减去a[l]是区间最小值的区间个数和a[r]是区间最大值的区间个数，最后再加上两个都是最值的区间个数即可

这样就可以写啦，前面两个用单调栈都可以轻松解决，记住维护最大值区间用递减序列，维护最小值用递增序列！！！

关键的就是怎么维护两个都是最值的区间，这个固定l或者r去找另一个就行，必须明白的是要得到这个结果我们需要什么（以固定r为例）：我们的l从r开始一直往左边扩的时候这个a[l]的值要是一直减小的并且是区间最小值，而且这个选定的区间中不能有比a[r]更大的数，想一下单调栈存储的就是左边第一个比自己小的数，正是我们想要的，我们只需要二分一下这个l到r的区间是否包含比r更大的数就行，第一个比r更大的数再用一个递减单调栈就又可以维护了，到这里就解决问题啦

```cpp[]
void solve(){
    int n;
    cin >> n;
    vector<int> a(n + 1);
    fore(i, 1, n + 1) cin >> a[i];
    int ans = (n + 1) * n / 2 + 1;
    vector<int> st = {0};
    fore(i, 1, n + 1) {
        while(st.back() != 0 && a[i] >= a[st.back()])
            st.pop_back();
        ans -= i - st.back();
        st.push_back(i);
    }
    st = {n + 1};
    for (int i = n; i >= 1; i--) {
        while(st.back() != n + 1 && a[i] <= a[st.back()])
            st.pop_back();
        ans -= st.back() - i;
        st.push_back(i);
    }
    vector<int> st1 = {0}, st2 = {0};
    fore(i, 1, n + 1) {
        while(st1.back() != 0 && a[i] >= a[st1.back()])
            st1.pop_back();
        while(st2.back() != 0 && a[i] < a[st2.back()])
            st2.pop_back();
        int l = 0, r = st2.size() - 1, mid;
        while(l < r) {
            mid = (l + r + 1) >> 1;
            if(st2[mid] <= st1.back()) l = mid;
            else r = mid - 1;
        }
        ans += st2.size() - 1 - l + 1;
        st1.push_back(i);
        st2.push_back(i);
    }
    cout << ans << endl;
}
```


















