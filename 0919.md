[J. Jesting Jabberwocky](https://codeforces.com/gym/104059/problem/J)

**题意：** 你现在有n张扑克牌，其花色分别用 h, s, c, d 表示，每次操作可以选择一张牌将其插入到任意一个位置，问最少需要多少次操作可以使得相同花色的全部放在一起

直接思考交换哪几张牌肯定很复杂，我们不妨思考哪些牌是可以不动的，要知道这个自然就会想到我们先给出一个花色的顺序，开始一堆是方片，然后是红心，等等

就好比是找到一个序列使得其中的每个字母都满足给定的关系，可以用一个dp维护，dp[i]可以由所有 j < i 的dp[j]转移过来，复杂度也不大

需要注意的是开始给出的p字符串必须是字典序最小的排列，这样才能遍历所有情况

```cpp[]
void solve(){
    string s, p;
    p = "cdhs";
    cin >> s;
    int ans = 0;
    do{
        vector<int> dp(4, 0);
        for(char c : s) {
            fore(i, 0, 4) {
                if(p[i] == c) {
                    int tmp = 0;
                    fore(j, 0, i + 1) tmp = max(tmp, dp[j]);
                    dp[i] = tmp + 1;
                }
            }
        }
        int maxn = 0;
        fore(i, 0, 4) maxn = max(maxn, dp[i]);
        ans = max(ans, maxn);

    } while (next_permutation(p.begin(), p.end()));
    cout << s.length() - ans << endl;
}
```
